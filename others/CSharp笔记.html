<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CSharp历史笔记 | Bin&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="个人学习记录">
    
    <link rel="preload" href="/assets/css/0.styles.bf69baaf.css" as="style"><link rel="preload" href="/assets/js/app.c519572e.js" as="script"><link rel="preload" href="/assets/js/2.b6ef3095.js" as="script"><link rel="preload" href="/assets/js/3.fa77217e.js" as="script"><link rel="preload" href="/assets/js/17.999ca336.js" as="script"><link rel="prefetch" href="/assets/js/10.14f550fc.js"><link rel="prefetch" href="/assets/js/11.464d316f.js"><link rel="prefetch" href="/assets/js/12.6ffea25e.js"><link rel="prefetch" href="/assets/js/13.d1c3b454.js"><link rel="prefetch" href="/assets/js/14.103579a4.js"><link rel="prefetch" href="/assets/js/15.dd5feed6.js"><link rel="prefetch" href="/assets/js/16.ce54d860.js"><link rel="prefetch" href="/assets/js/18.6b943f21.js"><link rel="prefetch" href="/assets/js/19.781dcc2b.js"><link rel="prefetch" href="/assets/js/20.60cc9b5d.js"><link rel="prefetch" href="/assets/js/21.3da4fd69.js"><link rel="prefetch" href="/assets/js/22.c6030360.js"><link rel="prefetch" href="/assets/js/23.32b7a93f.js"><link rel="prefetch" href="/assets/js/24.a78b3a95.js"><link rel="prefetch" href="/assets/js/4.23e7f437.js"><link rel="prefetch" href="/assets/js/5.8c30e054.js"><link rel="prefetch" href="/assets/js/6.554d8a26.js"><link rel="prefetch" href="/assets/js/7.58ec27f7.js"><link rel="prefetch" href="/assets/js/8.b58bc272.js"><link rel="prefetch" href="/assets/js/9.9c330930.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bf69baaf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Bin's blog" class="logo"> <span class="site-name can-hide">Bin's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontendbase/historynotes.html" class="nav-link">
  历史笔记
</a></li><li class="dropdown-item"><!----> <a href="/frontendbase/重学前端.html" class="nav-link">
  重学前端
</a></li><li class="dropdown-item"><!----> <a href="/frontendbase/blank.html" class="nav-link">
  待更新
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontendframe/historynotes.html" class="nav-link">
  历史笔记
</a></li><li class="dropdown-item"><!----> <a href="/frontendframe/手撕vue源码-01.html" class="nav-link">
  手撕vue源码系列
</a></li><li class="dropdown-item"><!----> <a href="/frontendframe/VUE开发实践笔记.html" class="nav-link">
  VUE开发实践笔记
</a></li><li class="dropdown-item"><!----> <a href="/frontendframe/blank.html" class="nav-link">
  待更新
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/others/常用调试工具和抓包工具.html" class="nav-link">
  常用调试工具和抓包工具
</a></li><li class="dropdown-item"><!----> <a href="/others/W3C学习.html" class="nav-link">
  W3C学习
</a></li><li class="dropdown-item"><!----> <a href="/others/CSharp笔记.html" class="nav-link">
  CSharp笔记
</a></li><li class="dropdown-item"><!----> <a href="/others/echarts.html" class="nav-link">
  echarts
</a></li><li class="dropdown-item"><!----> <a href="/others/dojo&amp;兼容问题.html" class="nav-link">
  dojo&amp;兼容问题
</a></li><li class="dropdown-item"><!----> <a href="/others/http网络请求状态码.html" class="nav-link">
  http网络请求状态码
</a></li><li class="dropdown-item"><!----> <a href="/others/SqlServer.html" class="nav-link">
  SqlServer
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践总结" class="dropdown-title"><span class="title">实践总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="实践总结" class="mobile-dropdown-title"><span class="title">实践总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/practice/blank.html" class="nav-link">
  待更新
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/bhuangdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端基础" class="dropdown-title"><span class="title">前端基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端基础" class="mobile-dropdown-title"><span class="title">前端基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontendbase/historynotes.html" class="nav-link">
  历史笔记
</a></li><li class="dropdown-item"><!----> <a href="/frontendbase/重学前端.html" class="nav-link">
  重学前端
</a></li><li class="dropdown-item"><!----> <a href="/frontendbase/blank.html" class="nav-link">
  待更新
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端框架" class="mobile-dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontendframe/historynotes.html" class="nav-link">
  历史笔记
</a></li><li class="dropdown-item"><!----> <a href="/frontendframe/手撕vue源码-01.html" class="nav-link">
  手撕vue源码系列
</a></li><li class="dropdown-item"><!----> <a href="/frontendframe/VUE开发实践笔记.html" class="nav-link">
  VUE开发实践笔记
</a></li><li class="dropdown-item"><!----> <a href="/frontendframe/blank.html" class="nav-link">
  待更新
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/others/常用调试工具和抓包工具.html" class="nav-link">
  常用调试工具和抓包工具
</a></li><li class="dropdown-item"><!----> <a href="/others/W3C学习.html" class="nav-link">
  W3C学习
</a></li><li class="dropdown-item"><!----> <a href="/others/CSharp笔记.html" class="nav-link">
  CSharp笔记
</a></li><li class="dropdown-item"><!----> <a href="/others/echarts.html" class="nav-link">
  echarts
</a></li><li class="dropdown-item"><!----> <a href="/others/dojo&amp;兼容问题.html" class="nav-link">
  dojo&amp;兼容问题
</a></li><li class="dropdown-item"><!----> <a href="/others/http网络请求状态码.html" class="nav-link">
  http网络请求状态码
</a></li><li class="dropdown-item"><!----> <a href="/others/SqlServer.html" class="nav-link">
  SqlServer
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="实践总结" class="dropdown-title"><span class="title">实践总结</span> <span class="arrow down"></span></button> <button type="button" aria-label="实践总结" class="mobile-dropdown-title"><span class="title">实践总结</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/practice/blank.html" class="nav-link">
  待更新
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://github.com/bhuangdev" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>CSharp历史笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#零散知识点" class="sidebar-link">零散知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于类" class="sidebar-link">关于类</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#字段-类型的变量" class="sidebar-link">字段：类型的变量</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#属性-一个方法或一对方法-看起来是一个字段" class="sidebar-link">属性：一个方法或一对方法，看起来是一个字段</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于泛型" class="sidebar-link">关于泛型</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于regex" class="sidebar-link">关于Regex</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于add" class="sidebar-link">关于Add</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于问号" class="sidebar-link">关于问号</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于重写、重载与覆写" class="sidebar-link">关于重写、重载与覆写</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#关于virtual与abstract" class="sidebar-link">关于virtual与abstract</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#判空方法" class="sidebar-link">判空方法</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#封装" class="sidebar-link">封装</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#string-format-方法的几种定义" class="sidebar-link">String.Format 方法的几种定义：</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#类型转换" class="sidebar-link">类型转换</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#隐式转换-小的类型范围向大的类型范围转换-直接转换" class="sidebar-link">隐式转换：  小的类型范围向大的类型范围转换，直接转换</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#显式转换-大的范围向小的范围转换" class="sidebar-link">显式转换：   大的范围向小的范围转换</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#通过method进行类型转换" class="sidebar-link">通过Method进行类型转换</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#装箱拆箱" class="sidebar-link">装箱拆箱</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#循环语句" class="sidebar-link">循环语句</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#逻辑语句" class="sidebar-link">逻辑语句</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#条件语句" class="sidebar-link">条件语句</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#垃圾回收、回调invoke" class="sidebar-link">垃圾回收、回调Invoke</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#垃圾回收-gc" class="sidebar-link">垃圾回收（GC）</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#异常处理" class="sidebar-link">异常处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#异步与线程" class="sidebar-link">异步与线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#async" class="sidebar-link">async</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#sleep和wait的区别有" class="sidebar-link">sleep和wait的区别有：</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#tips" class="sidebar-link">Tips</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#webapi" class="sidebar-link">webApi</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#集合类型" class="sidebar-link">集合类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#数组" class="sidebar-link">数组</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#数组列表arraylist" class="sidebar-link">数组列表ArrayList</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#list" class="sidebar-link">List</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#dictionary" class="sidebar-link">Dictionary</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#实体框架ef" class="sidebar-link">实体框架EF</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#官方解释ef" class="sidebar-link">官方解释EF</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#linq查询方式" class="sidebar-link">LINQ查询方式</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#entity-framework" class="sidebar-link">Entity Framework</a></li></ul></li><li><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#linq查询、lambda表达式" class="sidebar-link">LINQ查询、Lambda表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#lambda表达式" class="sidebar-link">Lambda表达式</a></li><li class="sidebar-sub-header"><a href="/others/CSharp%E7%AC%94%E8%AE%B0.html#linq查询" class="sidebar-link">LINQ查询</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="csharp历史笔记"><a href="#csharp历史笔记" class="header-anchor">#</a> CSharp历史笔记</h1> <h2 id="零散知识点"><a href="#零散知识点" class="header-anchor">#</a> 零散知识点</h2> <h3 id="关于类"><a href="#关于类" class="header-anchor">#</a> 关于类</h3> <p>DynamicForm  类与结构的区分  类类型的对象通过引用传递  结构类型的对象按值传递
包含成员：字段、常量、方法、属性、构造函数、索引器、运算符、事件、析构函数、类型</p> <p>·实例化对象----&gt; var 实例化对象名 = new 类名();</p> <h3 id="字段-类型的变量"><a href="#字段-类型的变量" class="header-anchor">#</a> 字段：类型的变量</h3> <p>·访问字段----&gt; 实例化对象名.字段名 =“xx”；</p> <h3 id="属性-一个方法或一对方法-看起来是一个字段"><a href="#属性-一个方法或一对方法-看起来是一个字段" class="header-anchor">#</a> 属性：一个方法或一对方法，看起来是一个字段</h3> <p>·只包含get set----&gt; public int 属性名(get; set;)</p> <p>函数&gt;方法<br>
函数成员不仅包含方法，也包含类或结构的一些非数据成员</p> <div class="language- extra-class"><pre class="language-text"><code>Response.Redirect(&quot;/xx/xxx.aspx&quot;); 重定向页面
Authenticated 身份验证
request[]获取参数
Contains 判断某字符串中是否包含某一字符串
IEnumerable&lt;T&gt; 数据查询返回对象       状态机，里面维护着T对象的状态迭代
parameters.FormId ?? 0, parameters.FormType, parameters.Year
---??---如果此运算符的左操作数不为null，则此运算符将返回左操作数，否则返回右操作数。
---int?---可空类型
Convert.Toxxx();    //类型转换
</code></pre></div><h3 id="关于泛型"><a href="#关于泛型" class="header-anchor">#</a> 关于泛型</h3> <p>延迟声明-------&gt;泛型举例</p> <p>一般：</p> <div class="language- extra-class"><pre class="language-text"><code>public static void ShowObject(object oParameter)
{
       Console.WriteLine(&quot;This is {0},parameter={1},type={2}&quot;,
       typeof(CommonMethod), oParameter.GetType().Name, oParameter);
}
</code></pre></div><p>泛型：</p> <div class="language- extra-class"><pre class="language-text"><code>public static void Show&lt;T&gt;(T tParameter)
{
    Console.WriteLine(&quot;This is {0},parameter={1},type={2}&quot;,
       typeof(GenericMethod), tParameter.GetType().Name, tParameter.ToString());
}
</code></pre></div><p>typeoff:为了获取某个实例具体引用的数据类型System.Type</p> <p>RelayCommand(() =&gt; this.AddPerson(), () =&gt; this.CanAddPerson());  的意思可以翻译为
·RelayCommand(参数一, 参数二);
·参数一 ：() =&gt; this.AddPerson()
·参数二 ：() =&gt; this.CanAddPerson()</p> <p>() =&gt; this.AddPerson() 的意思是 一个没有参数的方法，返回 this.AddPerson() 而这个返回值的类型不用指定 系统会自动判断</p> <p>{new Tuple&lt;int, string&gt;(TaxYears._2019, FormTypeNames.Form1099Misc), () =&gt; new _2019._1099MiscValidatorBase()}
元组有些对象的集合
最大的用处就是，不用为了一些简单的结构或对象而去新建一个类了</p> <h3 id="关于regex"><a href="#关于regex" class="header-anchor">#</a> 关于Regex</h3> <p>//Regex.IsMatch();//用来判断给定的字符串是否匹配某个正则表达式
//Regex.Match();//用来从给定的字符串中按照正则表达式的要求提取【一个】匹配的字符串
//Regex.Matches();//用来从给定的字符串中按照正则表达式的要求提取【所有】匹配的字符串
//Regex.Replace(); //替换所有正则表达式匹配的字符串为另外一个字符串。</p> <h3 id="关于add"><a href="#关于add" class="header-anchor">#</a> 关于Add</h3> <p>Add 是每次将单个元素添加到集合里面。
但是AddRange可以一次性添加多个元素到集合里面</p> <h3 id="关于问号"><a href="#关于问号" class="header-anchor">#</a> 关于问号</h3> <div class="language- extra-class"><pre><code>• x?y:z 表示如果表达式x为true，则返回y；如果x为false，则返回z
• a??b 当a为null时则返回b，a不为null时则返回a本身
• int? 表示可空的整形，DateTime? 表示可为空的时间
	○ int？ iNullale = 100;   &lt;==&gt;   System.Nullable&lt;int&gt; iNullable1 = 100;
</code></pre></div><h3 id="关于重写、重载与覆写"><a href="#关于重写、重载与覆写" class="header-anchor">#</a> 关于重写、重载与覆写</h3> <p>override重写  在子类中重写父类中的方法，两个函数的函数特征（函数名，参数类型和个数）相同
1.重写基方法必须具有与override方法相同的签名。
2.override声明不能更改virtual方法的可访问性，且override方法与virtual方法必须具有相同级别访问修饰符。
3.不能用new、static、virtual修饰符修改override方法。
4.重写属性声明必须指定与继承的属性完全相同的访问修饰符、类型和名称。
5.重写的属性必须是virtual、abstract或override。
6.不能重写非虚方法或静态方法。
7.父类中有abstract，那么子类同名方法必定有override，若父类中有 virtual方法，子类同名方法不一定是override，可能是overload。
8.override必定有父子类关系。</p> <p>overload重载  在同一个类中方法名相同、参数或返回值不同的多个方法
1.出现在同一个类中。
2.参数列表不同或返回类型和参数列表都不同，只有返回类型不同不能重载。(参数列表包括参数个数和参数类型)</p> <p>overwrite覆写 用new实现，在子类中用new关键字修饰定义的与父类中同名的方法，也称为覆盖，覆盖不会改变父类方法的功能</p> <h3 id="关于virtual与abstract"><a href="#关于virtual与abstract" class="header-anchor">#</a> 关于virtual与abstract</h3> <p>共同点：用来修饰方法不能是private
区别：
• virtual修饰的方法必须有实现
abstract修饰的方法一定不能实现</p> <div class="language- extra-class"><pre><code>• virtual可以被子类重写（override）
abstract必须被子类重写

• 如果类成员被abstract修饰，则该类前必须加abstract，因为只有抽象类才可以有抽象方法

• 无法创建abstract类的实例，只能被继承无法实例化

• c#如果要在子类中重写方法，必须在父类方法前加virtual，在子类方法前加override，这样避免了在子类中不小心重写父类方法
</code></pre></div><h3 id="判空方法"><a href="#判空方法" class="header-anchor">#</a> 判空方法</h3> <p>IsNullOrEmpty 判断是null还是空
IsNullOrBlank 判断是null还是空字符串
IsNullOrWhiteSpace  判断是null、空还是仅由空白字符组成</p> <h3 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h3> <p>protected：范围---&gt;本身的class或继承它的class
Internal：范围---&gt;程序集内</p> <p>First：取序列中满足条件的第一个元素，如果没有元素满足条件，则抛出异常
FirstOrDefault：取序列中满足条件的第一个元素，如果没有元素满足条件，则返回默认值</p> <p>InvariantCultureIgnoreCase 不同区域信息下都忽略大小写
StringComparison 比较
string.CompareOrdinal(payKind, &quot;H&quot;)      如果payKind里的字符串和“H”相同，则返回0，第一个小于第二个字符串，返回值小于零，反之大于零</p> <p>C#中trim() 的功能:删除字符串首部和尾部的空格
Equals()判断是否对同一个对象的引用（即堆中的内容是否相同）</p> <p>IgnoreCase 属性
设置或返回一个Boolean值，指明模式搜索是否区分大小写</p> <p>Tuple元组
组元使用泛型来简化类的定义，多用于方法的返回值。在函数需要返回多个类型的时候，就不必使用out , ref等关键字了，直接定义一个Tuple类型，使用起来非常方便</p> <p>()=&gt;Lambda运算符
左边挨着的是定义，右边就是对定义的操作，并返回该定义的值</p> <p>this
代表当前类的实例对象</p> <h3 id="string-format-方法的几种定义"><a href="#string-format-方法的几种定义" class="header-anchor">#</a> String.Format 方法的几种定义：</h3> <p>String.Format (String, Object) 将指定的 String 中的格式项替换为指定的 Object 实例的值的文本等效项。
String.Format (String, Object[]) 将指定 String 中的格式项替换为指定数组中相应 Object 实例的值的文本等效项。
String.Format (IFormatProvider, String, Object[]) 将指定 String 中的格式项替换为指定数组中相应 Object 实例的值的文本等效项。指定的参数提供区域性特定的格式设置信息。
String.Format (String, Object, Object) 将指定的 String 中的格式项替换为两个指定的 Object 实例的值的文本等效项。
String.Format (String, Object, Object, Object) 将指定的 String 中的格式项替换为三个指定的 Object 实例的值的文本等效项。</p> <p>用字符串分隔 xx.Split</p> <p>lazy loading与eager loading
两种加载数据的方式没有什么好坏之分，只是从不同的角度出发适用于不同情况环境。延迟加载更具有灵活性，类似于分治法，每次加载少量数据，分多次加载。但是当主表数据数量过多时，会频繁访问数据库降低性能。预加载只要访问一次数据库就可以拿到全部的数据，放到内存中。但是当数据量很多，或者实体级联关系复杂时要特别注意性能了；实体关系复杂时EF自动生成的sql语句可能会非常复杂，这点也要特别注意。</p> <h2 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h2> <h3 id="隐式转换-小的类型范围向大的类型范围转换-直接转换"><a href="#隐式转换-小的类型范围向大的类型范围转换-直接转换" class="header-anchor">#</a> 隐式转换：  小的类型范围向大的类型范围转换，直接转换</h3> <p>int i = 10;
long l = i;</p> <p>C1 c1 = new C2();       C1为父类，C2为子类</p> <h3 id="显式转换-大的范围向小的范围转换"><a href="#显式转换-大的范围向小的范围转换" class="header-anchor">#</a> 显式转换：   大的范围向小的范围转换</h3> <p>double d = 10.01
int iFromD = (int)d;</p> <p>C1 c11 = new C1();
C2 c2 = (C2)c11;</p> <p>会报错</p> <p>C2 c22 = c11 as C2     //as将c11的类型转化为C2   as只能转换引用类型和空类型，不成功返回空</p> <h3 id="通过method进行类型转换"><a href="#通过method进行类型转换" class="header-anchor">#</a> 通过Method进行类型转换</h3> <div class="language- extra-class"><pre class="language-text"><code>string iForm1 = i.ToString();
int iForm2 = Convert.ToInt32(&quot;100&quot;);
int iForm3 = Int32.Parse(&quot;101&quot;);
int iForm4;
bool succed = Int32.TryParse(&quot;102&quot;,out iForm4);
//Iconventible.TypeConventer   实现自己的类型 转换方法
</code></pre></div><h3 id="装箱拆箱"><a href="#装箱拆箱" class="header-anchor">#</a> 装箱拆箱</h3> <p>装箱：将值类型转变成引用类型
不需要特别的语法，其实就是一个隐式转换
拆箱：引用类型转变为值类型</p> <p>int？ 可为空类型</p> <h3 id="循环语句"><a href="#循环语句" class="header-anchor">#</a> 循环语句</h3> <p>1.for
2.foreach</p> <div class="language- extra-class"><pre class="language-text"><code>	//前提是必须实现了IEumerable接口
	List&lt;int&gt; listInt = new List&lt;int&gt;() { 1, 2, 3 , 4 , 5 };
	foreach(int intInList in listInt)
	{
		Console.WriteLine(intInList);
	}
</code></pre></div><p>3.while-do
4.do-while</p> <p>Console.ReadLine();</p> <p>//问题：几种循环方式分别在什么情况下用比较好？</p> <h2 id="逻辑语句"><a href="#逻辑语句" class="header-anchor">#</a> 逻辑语句</h2> <h3 id="条件语句"><a href="#条件语句" class="header-anchor">#</a> 条件语句</h3> <div class="language- extra-class"><pre><code>if语句
	&amp; | &amp;&amp; ||的区别
		对于&amp;&amp;  ||运算的对象是逻辑值，也就是True/False
		对于&amp; |运算的对象是位，也就是1/0
	&amp;：按位与，对两个条件都进行判断
	&amp;&amp;：逻辑与，只要一个条件满足，另一个条件就不会执行
	|：按位或，对两个条件都进行判断
	||：逻辑或，只要一个条件满足，另一个条件就不会执行
switch语句
</code></pre></div><h2 id="垃圾回收、回调invoke"><a href="#垃圾回收、回调invoke" class="header-anchor">#</a> 垃圾回收、回调Invoke</h2> <h3 id="垃圾回收-gc"><a href="#垃圾回收-gc" class="header-anchor">#</a> 垃圾回收（GC）</h3> <p>值类型（常见类型：整形、浮点型、布尔型、枚举）
保存在Stack上，随着函数的执行作用域执行完毕而自动出栈，不是GC所关心的对象</p> <p>引用类型（常见类型：数组、字符串、接口、委托、Object等）
保存在heap上，由GC处理</p> <p>拆箱：将引用类型转化为值类型
装箱：将值类型转化为引用类型</p> <p>GC机制问题：
1.GC不能释放所有的资源，自动释放非托管资源
2.GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性</p> <p>Then you know , what is the 托管or非托管 resource.
托管：.net可以自动进行回收资源，主要指托管堆上分匹配的内存资源
非托管：.net不知道如何回收的资源，常见为文件、窗口、网络连接、数据库连接、画刷、图标等</p> <h2 id="异常处理"><a href="#异常处理" class="header-anchor">#</a> 异常处理</h2> <p>异常处理机制</p> <div class="language- extra-class"><pre class="language-text"><code>	try{
	} 
	catch{
	throw;
	} 
	finally{
	}
</code></pre></div><h2 id="异步与线程"><a href="#异步与线程" class="header-anchor">#</a> 异步与线程</h2> <h3 id="async"><a href="#async" class="header-anchor">#</a> async</h3> <p>async固定线程在执行异步任务与wait Task.Run()---每次会启动一个新的线程执行Task</p> <p>https://www.cnblogs.com/neverc/p/4653539.html    回去好好研究研究</p> <p>sleep()可以将一个线程睡眠，参数可以指定一个时间。
而wait()可以将一个线程挂起，直到超时或者该线程被唤醒</p> <p>其实两者都可以让线程暂停一段时间,但是本质的区别是一个线程的运行状态控制,一个是线程之间的通讯的问题</p> <h3 id="sleep和wait的区别有"><a href="#sleep和wait的区别有" class="header-anchor">#</a> sleep和wait的区别有：</h3> <p>1，这两个方法来自不同的类分别是Thread和Object
2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在
任何地方使用</p> <div class="language- extra-class"><pre class="language-text"><code>synchronized(x){
    x.notify()
    //或者wait()
}
</code></pre></div><p>4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</p> <h2 id="tips"><a href="#tips" class="header-anchor">#</a> Tips</h2> <p>不能在foreach里写数据库操作 频繁访问数据库不好</p> <h2 id="webapi"><a href="#webapi" class="header-anchor">#</a> webApi</h2> <p>构建REST-ful服务
三种主流web服务交互方法：
REST-ful---Representational State Transfer 表征性状态传输
SOAP---Sample Object Access protocol 简单对象访问协议
XML-RPC</p> <p>REST-ful
是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。
RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源</p> <h2 id="集合类型"><a href="#集合类型" class="header-anchor">#</a> 集合类型</h2> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <div class="language- extra-class"><pre class="language-text"><code>int[] numbers = new int[5]; // 数组内容类型  数组名称  实例化  同第一个写法，加一个数组长度5
	int[] number2 = new int[5] {1,1,1,1,}/new int[] {1,1,1}/{1,1,1,}
string[,] names = new string[5, 4];//二维数组，5x4
	string[,] name2 = {{&quot;g&quot;,&quot;k&quot;},{&quot;j&quot;,&quot;h&quot;}};
byte[][] scores = new byte[5][];//数组的数组，每个维度里的值都是一个数组，但长度不定
	int[][] numbers3 = {new int[]{1,2,3.},new int[]P{4,5,6,7}};                                           通过索引获值
</code></pre></div><h3 id="数组列表arraylist"><a href="#数组列表arraylist" class="header-anchor">#</a> 数组列表ArrayList</h3> <p>非强类型</p> <p>ArrayList al = new ArrayList();
//方便添加和删除数组中的元素
al.Add(5);
al.Add(100);
al.Remove(5);
foreach(var e in al)
{
Console.WriteLine(e);
}
Console.ReadLine();</p> <h3 id="list"><a href="#list" class="header-anchor">#</a> List</h3> <p>推荐</p> <div class="language- extra-class"><pre class="language-text"><code>List&lt;int&gt; intList = new List&lt;int&gt;(); 
intList.Add(500);  //增加
intList.AddRange(new int[] {501,502});//添加一串
Console.WriteLine(intList.Contains(200));//是否包含一个数值
Console.WriteLine(intList.IndexOf(501));//查找某个数值的位置
intList.Remove(501);//删除
intList.Insert(1,100);//插入
</code></pre></div><p>不通过位置访问其他成员：通过key访问---哈希表
相当于每一位都有一个对应的key(主键值)和value(对应的值)</p> <div class="language- extra-class"><pre class="language-text"><code>Hashtable ht = new Hashtable();
ht.Add(&quot;first&quot;,&quot;jike&quot;);
ht.Add(&quot;second&quot;,&quot;xueyuan&quot;);
Console.WrtieLine(ht[&quot;second&quot;]);
</code></pre></div><p>缺点：类型不安全</p> <h3 id="dictionary"><a href="#dictionary" class="header-anchor">#</a> Dictionary</h3> <p>弥补：用Dictionary
Dictionary&lt;string,string&gt; d=new Dictionary&lt;string,string&gt;{};</p> <p>SortedList&lt;int,int&gt; sl = new SorteList&lt;int,int&gt;();//经过排序的list</p> <p>stack堆栈数据集合，先进后出
queue队列，先进先出</p> <h2 id="实体框架ef"><a href="#实体框架ef" class="header-anchor">#</a> 实体框架EF</h2> <h3 id="官方解释ef"><a href="#官方解释ef" class="header-anchor">#</a> 官方解释EF</h3> <p>微软官方提供的ORM工具，让开发人员节省数据库访问的代码时间。
EF提供变更跟踪、唯一性约束、惰性加载、查询事务等</p> <p>其实Entity Framework的底层也是调用Ado.Net,它是更高层次的封装.作为数据访问的技术,EntityFramework的设计有高扩展性,这一点可体现在其映射定义的灵活性.简单地说,使用Entity Framework可以充分地定义与数据库表映射的实体,这个实体可以直接用于业务逻辑层或作为服务的数据契约.使用EF后,可以将实体类的设计工作完全放在EDM的设计过程中,而不需要手工写那些大同小异的代码,令人欣喜的是这个实体模型可以在运行时修改并生效,做到一改全改.我们开发时也不用再频繁地与数据库打交道,我们操作实体模型的同时EF框架自动完成了对数据库的操作.</p> <p>三种模式：
DataBase First传统的表驱动方式创建EDM，然后通过EDM生成模型和数据层代码。除生成实体模型和自跟踪实现模型，还支持生成轻型DbContext。</p> <p>Model First先创建EDM模型，再生成DDL数据库脚本和模型和数据层代码。除生成实体模型和自跟踪实现模型，支持生成轻型DbContext。</p> <p>Code First手动创建POCO模型，数据层DbContext及映射关系，通过Database.SetInitializer生成数据库，这种方式较灵活，但是代码工作较多。</p> <p>Context.tt  用于生成的context类，它的目录下包含一个School.Context.cs 文件
Xx.tt用于生成表映射的实体类</p> <h3 id="linq查询方式"><a href="#linq查询方式" class="header-anchor">#</a> LINQ查询方式</h3> <p>例：</p> <div class="language- extra-class"><pre class="language-text"><code>LINQ Query syntax:
using (var context = new SchoolDBEntities())
{
var L2EQuery = from st in context.Students
where st.StudentName == &quot;Bill&quot;select st;
 
var student = L2EQuery.FirstOrDefault&lt;Student&gt;();
}
</code></pre></div><h3 id="entity-framework"><a href="#entity-framework" class="header-anchor">#</a> Entity Framework</h3> <ol><li>嘛是EF
ADO.NET Entity Framework,以ADO.NET为基础发展出来的对象关系对应解决方案
Entity Framework 是 ORMapping 的一种具体实现</li> <li>嘛是ORM
ORM-- ObjectRelation Mapping , 即对象关系映射框架/数据持久化框架,是根据实体对象操作数据表中数据的一种面向对象的操作框架</li> <li>EF开源
https://entityframework.codeplex.com</li></ol> <p>Entity</p> <ol><li>种类 POCO
简单的
复杂的</li> <li>相互关系</li> <li>生命周期</li></ol> <h2 id="linq查询、lambda表达式"><a href="#linq查询、lambda表达式" class="header-anchor">#</a> LINQ查询、Lambda表达式</h2> <h3 id="lambda表达式"><a href="#lambda表达式" class="header-anchor">#</a> Lambda表达式</h3> <p>lambda表达式：可用于创建委托或表达式目录树类型的匿名函数
lambda运算符=&gt; 读作“goes to” 左边是输入参数，右边是表达式或语句块
左边输入的参数  右边对参数进行处理，之后返回结果</p> <p>语句lambda
（委托与lambda表达式）</p> <div class="language- extra-class"><pre class="language-text"><code>delegate void TestDelegate(string s);      //delegate是一种声明
…
TestDelegate myDel = n =&gt; { string s = n + &quot; &quot; + &quot;World&quot;; Console.WriteLine(s); };
myDel(&quot;Hello&quot;);                                             //myDel是一个方法

（LINQ语句与lambda表达式）
List&lt;string&gt; Citys= new List&lt;string&gt;()    //定义一个citys集合，初始化一些数据
{
      &quot;BeiJing&quot;,
      &quot;ShangHai&quot;,
      &quot;Tianjin&quot;,
      &quot;GuangDong&quot;                                                        
};
var result = Citys.First(c =&gt; c.Length &gt; 7);    //调用LINQ的First方法，查询出来长度大于7的第一个结果
</code></pre></div><p>如何定义和使用lambda表达式（应用）</p> <div class="language- extra-class"><pre class="language-text"><code>Public void LambdaFun(string str,Func&lt;string,string&gt; func)
{
	Console.WriteLine(func(str));
}

LambdaFun(&quot;BeiJing 2013&quot;,s=&gt;
{
	If(s.Contains(&quot;2013&quot;))
	{
		s = s.Replace(&quot;2013&quot;,&quot;2014&quot;);
	}
	return s;
	
});
</code></pre></div><h3 id="linq查询"><a href="#linq查询" class="header-anchor">#</a> LINQ查询</h3> <p>语言集成查询
三个不同操作组成：创建数据源、创建查询、执行查询</p> <div class="language- extra-class"><pre class="language-text"><code>1）Func委托
当你想从lambda表达式返回一些东西时
使用Func&lt;in T,out TResult&gt; delegate  T是输入参数的类型，TResult是返回类型
2）Action委托
Action&lt;in T&gt; 只有输入参数，不需要返回值
</code></pre></div><p>LINQ其实就是对集合提供类似于sql一般的操作。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/31/2021, 7:08:03 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c519572e.js" defer></script><script src="/assets/js/2.b6ef3095.js" defer></script><script src="/assets/js/3.fa77217e.js" defer></script><script src="/assets/js/17.999ca336.js" defer></script>
  </body>
</html>
